{"version":3,"sources":["webpack://graphology-gremlin/webpack/universalModuleDefinition","webpack://graphology-gremlin/./src/traversal/graphTraversalSource.ts","webpack://graphology-gremlin/./src/type/index.ts","webpack://graphology-gremlin/./src/type/edge.ts","webpack://graphology-gremlin/./src/type/vertex.ts","webpack://graphology-gremlin/./src/type/path.ts","webpack://graphology-gremlin/./src/type/traverser.ts","webpack://graphology-gremlin/./src/type/graphConfiguration.ts","webpack://graphology-gremlin/./src/traversal/graphTraversal.ts","webpack://graphology-gremlin/./src/step/filter/hasLabel.ts","webpack://graphology-gremlin/./src/step/filter/generic.ts","webpack://graphology-gremlin/./src/step/generic.ts","webpack://graphology-gremlin/./src/step/start/addE.ts","webpack://graphology-gremlin/./src/step/map/generic.ts","webpack://graphology-gremlin/./src/step/start/addV.ts","webpack://graphology-gremlin/./src/step/start/E.ts","webpack://graphology-gremlin/./src/step/start/V.ts","webpack://graphology-gremlin/webpack/bootstrap","webpack://graphology-gremlin/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","graph","config","DEFAULT_GRAPH_CONFIGURATION","key","value","ids","gt","GraphTraversal","addStep","VStep","nodes","length","map","id","Traverser","addStart","Symbol","iterator","AddVStep","EStep","edges","AddEStep","Error","Edge","Vertex","Path","labels","properties","path","segments","source","target","label","copyPath","concat","push","vertex_label_field","edge_label_field","steps","getTarget","next","step","start","forEach","HasLabelStep","result","ir","done","Set","add","FilterStep","traversal","super","traverser","includes","Step","fn","nextFound","MapStep","makeNextTraverser","getLabel","node","getGraph","addNode","Date","getTime","props","getNodeAttributes","getConfig","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","GraphTraversalSource"],"mappings":"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","file":"rgraphology-gremlin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"graphology-gremlin\"] = factory();\n\telse\n\t\troot[\"graphology-gremlin\"] = factory();\n})(this, function() {\nreturn ","import Graph from \"graphology\";\nimport { NodeKey, EdgeKey } from \"graphology-types\";\nimport { Traverser, Vertex, Edge, GraphConfiguration, DEFAULT_GRAPH_CONFIGURATION } from \"../type\";\nimport { GraphTraversal } from \"./graphTraversal\";\n// start steps\nimport { AddEStep } from \"../step/start/addE\";\nimport { AddVStep } from \"../step/start/addV\";\nimport { EStep } from \"../step/start/E\";\nimport { VStep } from \"../step/start/V\";\n\n/**\n * Extract of https://github.com/apache/tinkerpop/blob/master/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/TraversalSource.java\n *\n * A {@code TraversalSource} is used to create {@link Traversal} instances.\n * A traversal source can generate any number of {@link Traversal} instances.\n * A traversal source is primarily composed of a {@link Graph} and a {@link TraversalStrategies}.\n * Various {@code withXXX}-based methods are used to configure the traversal strategies (called \"configurations\").\n * Various other methods (dependent on the traversal source type) will then generate a traversal given the graph and configured strategies (called \"spawns\").\n * A traversal source is immutable in that fluent chaining of configurations create new traversal sources.\n * This is unlike {@link Traversal} and {@link GraphComputer}, where chained methods configure the same instance.\n * Every traversal source implementation must maintain two constructors to enable proper reflection-based construction.\n * <p/>\n * {@code TraversalSource(Graph)} and {@code TraversalSource(Graph,TraversalStrategies)}\n *\n * @author Marko A. Rodriguez (http://markorodriguez.com)\n * @author Stephen Mallette (http://stephen.genoprime.com)\n */\nexport class GraphTraversalSource {\n  private graph: Graph;\n  private config: GraphConfiguration = DEFAULT_GRAPH_CONFIGURATION;\n\n  constructor(graph: Graph) {\n    this.graph = graph;\n  }\n\n  with(key: keyof GraphConfiguration, value: string): this {\n    this.config[key] = value;\n    return this;\n  }\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  // ~ Start steps\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  // Those steps are executed directly and result are passed to the traversal\n  // constructor for its start\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n  /**\n   * List all vertex of the graph or a selection.\n   */\n  public V<E>(...ids: Array<NodeKey>): GraphTraversal<NodeKey, Vertex> {\n    const gt = new GraphTraversal<NodeKey, Vertex>(this.graph, this.config);\n    gt.addStep(new VStep(gt));\n    const nodes = (ids.length > 0 ? ids : this.graph.nodes()).map((id: NodeKey) => new Traverser(id));\n    gt.addStart(nodes[Symbol.iterator]());\n    return gt;\n  }\n\n  /**\n   * Create a new vertex.\n   */\n  public addV<E>(): GraphTraversal<null, Vertex> {\n    const gt = new GraphTraversal<null, Vertex>(this.graph, this.config);\n    gt.addStep(new AddVStep(gt));\n    const iteratorArray = [null];\n    gt.addStart(iteratorArray[Symbol.iterator]());\n    return gt;\n  }\n\n  /**\n   * List all edges of the graph or a selection.\n   */\n  public E<E>(...ids: Array<EdgeKey>): GraphTraversal<EdgeKey, Edge> {\n    const gt = new GraphTraversal<EdgeKey, Edge>(this.graph, this.config);\n    gt.addStep(new EStep(gt));\n    const edges = (ids.length > 0 ? ids : this.graph.edges()).map((id: EdgeKey) => new Traverser(id));\n    gt.addStart(edges[Symbol.iterator]());\n    return gt;\n  }\n\n  /**\n   * Create a new edge.\n   */\n  public addE<E>(): GraphTraversal<null, Edge> {\n    const gt = new GraphTraversal<null, Edge>(this.graph, this.config);\n    gt.addStep(new AddEStep(gt));\n    const iteratorArray = [null];\n    gt.addStart(iteratorArray[Symbol.iterator]());\n    return gt;\n  }\n\n  public inject(): GraphTraversal<any, any> {\n    throw new Error(\"Not implemented\");\n  }\n}\n","import { Edge } from \"./edge\";\nimport { Vertex } from \"./vertex\";\nimport { Path, PathSegment } from \"./path\";\nimport { Traverser } from \"./traverser\";\nimport { GraphConfiguration, DEFAULT_GRAPH_CONFIGURATION } from \"./graphConfiguration\";\n\nexport { Edge, Vertex, Path, PathSegment, Traverser, GraphConfiguration, DEFAULT_GRAPH_CONFIGURATION };\n","import { EdgeKey } from \"graphology-types\";\n\n// Lazy ?\n// Give the graph internally + some config for the edge type ?\n// What to do for creation ?\nexport class Edge {\n  id: EdgeKey | null = null;\n\n  constructor(id?: EdgeKey) {\n    if (id) this.id = id;\n  }\n}\n","import { NodeKey } from \"graphology-types\";\n\n// Lazy ?\n// Give the graph internally + some config for node labels ?\n// What to do for creation ?\nexport class Vertex {\n  id: NodeKey;\n  labels: Array<string>;\n  properties: { [key: string]: unknown };\n\n  constructor(id: NodeKey, labels: Array<string> = [], properties: { [key: string]: unknown } = {}) {\n    this.id = id;\n    this.labels = labels;\n    this.properties = properties;\n  }\n}\n","import { Vertex } from \"./vertex\";\nimport { Edge } from \"./edge\";\n\nexport interface PathSegment {\n  source: Vertex;\n  edge: Edge;\n  target: Vertex;\n}\n\nexport class Path {\n  source: Vertex;\n  target: Vertex | null;\n  segments: Array<PathSegment> = [];\n\n  constructor(path: Array<PathSegment> | Vertex) {\n    if (path instanceof Vertex) {\n      this.source = path;\n    } else {\n      if (path.length === 0) throw new Error(\"Can't build a path with an empty array\");\n      this.segments = path;\n      this.source = this.segments[0].source;\n      this.target = this.segments[this.segments.length - 1].target;\n    }\n  }\n}\n","/**\n * Extract of https://github.com/apache/tinkerpop/blob/master/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/Traverser.java\n *\n * A {@code Traverser} represents the current state of an object flowing through a {@link Traversal}.\n * A traverser maintains a reference to the current object, a traverser-local \"sack\", a traversal-global sideEffect,\n * a bulk count, and a path history.\n * <p/>\n * Different types of traversers can exist depending on the semantics of the traversal and the desire for\n * space/time optimizations of the developer.\n */\nexport class Traverser<S> {\n  /**\n   * The inner value of the traverser.\n   */\n  value: S;\n  /**\n   * Traverser path, ie. the value of each previous steps with their name\n   */\n  path: Array<{ label: string; value: any }>;\n\n  /**\n   * Default constructor.\n   */\n  constructor(value: S, path?: Array<any>) {\n    this.value = value;\n    if (path) this.path = path;\n  }\n\n  /**\n   * Return the value of the traverser.\n   */\n  get(): S {\n    return this.value;\n  }\n\n  /**\n   * Return the path of the traverser.\n   */\n  getPath(): Array<any> {\n    return this.path;\n  }\n\n  /**\n   * Create a new traverser for the next iteration.\n   */\n  makeNextTraverser<T>(label: string, value: T) {\n    const copyPath = [].concat(this.path);\n    copyPath.push({ label, value });\n    return new Traverser<T>(value, copyPath);\n  }\n\n  // loops();\n  // bulk();\n  // sack();\n  // sideEffects(arg?: string);\n}\n","export interface GraphConfiguration {\n  vertex_label_field: string;\n  edge_label_field: string;\n}\n\n//TODO add a method to create a node id.\nexport const DEFAULT_GRAPH_CONFIGURATION: GraphConfiguration = {\n  vertex_label_field: \"@labels\",\n  edge_label_field: \"@type\",\n};\n","import Graph from \"graphology\";\nimport { Step, StepConstructor } from \"../step/generic\";\nimport { GraphConfiguration, Traverser } from \"../type\";\n// filter step\nimport { HasLabelStep } from \"../step/filter/hasLabel\";\n\n/**\n * Extract from https://github.com/apache/tinkerpop/blob/master/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/Traversal.java\n *\n * A {@link Traversal} represents a directed walk over a {@link Graph}.\n * This is the base interface for all traversal's, where each extending interface is seen as a domain specific language.\n * For example, {@link GraphTraversal} is a domain specific language for traversing a graph using \"graph concepts\" (e.g. vertices, edges).\n * Another example may represent the graph using \"social concepts\" (e.g. people, cities, artifacts).\n * A {@link Traversal} is evaluated in one of two ways: iterator-based OLTP or {@link GraphComputer}-based OLAP.\n * OLTP traversals leverage an iterator and are executed within a single JVM (with data access allowed to be remote).\n * OLAP traversals leverage {@link GraphComputer} and are executed between multiple JVMs (and/or cores).\n *\n * @author Marko A. Rodriguez (http://markorodriguez.com)\n */\nexport class GraphTraversal<S, E> implements Iterator<Traverser<E>> {\n  private graph: Graph;\n  private config: GraphConfiguration;\n  private steps: Array<Step<any, any>> = [];\n  private start: Iterator<Traverser<S>>;\n  private target: Iterator<Traverser<E>> | null = null;\n\n  constructor(graph: Graph, config: GraphConfiguration) {\n    this.graph = graph;\n    this.config = config;\n  }\n\n  /**\n   * Consume the iterator result.\n   */\n  next(): IteratorResult<Traverser<E>> {\n    return this.getTarget().next();\n  }\n\n  /**\n   * Add a step to the traversal.\n   */\n  addStep(step: Step<any, any>): this {\n    this.steps.push(step);\n    return this;\n  }\n\n  /**\n   * Add a start to the traversal.\n   */\n  addStart(start: Iterator<Traverser<S>>): this {\n    this.start = start;\n    return this;\n  }\n\n  getGraph(): Graph {\n    return this.graph;\n  }\n\n  getConfig(): GraphConfiguration {\n    return this.config;\n  }\n\n  /**\n   * Return the target iterator of the traversal.\n   * The target iterator is created if it's not the case.\n   * So this function in fact execute the traversal.\n   */\n  private getTarget(): Iterator<Traverser<E>> {\n    if (this.target === null) {\n      let target: Iterator<Traverser<any>> = this.start;\n      this.steps.forEach((step: Step<any, any>) => {\n        step.addStart(target);\n        target = step;\n      });\n      this.target = target as Iterator<Traverser<E>>;\n    }\n    return this.target;\n  }\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  // ~ Filter steps\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  public hasLabel(label: string): this {\n    this.addStep(new HasLabelStep(this, label));\n    return this;\n  }\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  // ~ Terminal steps\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n  /**\n   * Give the traversal result as a list.\n   */\n  public toList(): Array<E> {\n    const result: Array<E> = [];\n    let ir = this.next();\n    while (!ir.done) {\n      result.push(ir.value);\n      ir = this.next();\n    }\n    return result;\n  }\n\n  /**\n   * Give the traversal result as a Set.\n   * TODO: need to remove duplicates by checking there footprint ???\n   */\n  public toSet(): Set<E> {\n    const result: Set<E> = new Set<E>();\n    let ir = this.next();\n    while (!ir.done) {\n      result.add(ir.value);\n      ir = this.next();\n    }\n    return result;\n  }\n\n  /**\n   * Give the explain of the traversal.\n   */\n  public explain(): void {\n    throw new Error(\"Not implemented\");\n  }\n}\n","import { Vertex, Traverser } from \"../../type\";\nimport { GraphTraversal } from \"../../traversal/graphTraversal\";\nimport { FilterStep } from \"./generic\";\n\n/**\n * Retrieve a list of edges or all graph edges.\n * Ex: g.E()\n */\nexport class HasLabelStep extends FilterStep<Vertex> {\n  /**\n   * Default constructor.\n   */\n  constructor(traversal: GraphTraversal<any, any>, label: string) {\n    super(\"hasLabel\", traversal, (traverser: Traverser<Vertex>): boolean => {\n      return traverser.value.labels.includes(label);\n    });\n  }\n}\n","import { NodeKey } from \"graphology-types\";\nimport { GraphTraversal } from \"../../traversal/graphTraversal\";\nimport { Path, Traverser, Vertex } from \"../../type\";\nimport { Step } from \"../generic\";\n\n/**\n * Retrieve a list of vertex or all graph vertex.\n * Ex: g.V()\n */\nexport class FilterStep<S> extends Step<S, S> {\n  label: string;\n  fn: (source: Traverser<S>) => boolean;\n\n  /**\n   * Default constructor.\n   */\n  constructor(label: string, traversal: GraphTraversal<S, S>, fn: (source: Traverser<S>) => boolean) {\n    super(traversal);\n    this.label = label;\n    this.fn = fn;\n  }\n\n  getLabel(): string {\n    return this.label;\n  }\n\n  next(): IteratorResult<Traverser<S>> {\n    let ir = this.start.next();\n    let nextFound = false;\n    while (!ir.done && !nextFound) {\n      nextFound = this.fn(ir.value);\n      if (!nextFound) ir = this.start.next();\n    }\n    return ir;\n  }\n}\n","import { GraphTraversal } from \"../traversal/graphTraversal\";\nimport { Traverser } from \"../type\";\n/**\n * Extract of https://github.com/apache/tinkerpop/blob/master/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/Step.java\n *\n * A {@link Step} denotes a unit of computation within a {@link Traversal}.\n * A step takes an incoming object and yields an outgoing object.\n * Steps are chained together in a {@link Traversal} to yield a lazy function chain of computation.\n * <p/>\n * In the constructor of a Step, never store explicit sideEffect objects in {@link TraversalSideEffects}.\n * If a sideEffect needs to be registered with the {@link Traversal}, use SideEffects.registerSupplier().\n *\n * @param <S> The incoming object type of the step\n * @param <E> The outgoing object type of the step\n */\nexport abstract class Step<S, E> implements Iterator<Traverser<E>> {\n  /**\n   * Traversal of which the step behave.\n   */\n  traversal: GraphTraversal<any, any>;\n\n  /**\n   * The starts object for the step.\n   */\n  start: Iterator<Traverser<S>> | null = null;\n\n  /**\n   * Default constructor.\n   */\n  constructor(traversal: GraphTraversal<any, any>) {\n    this.traversal = traversal;\n  }\n\n  /**\n   *  Add the starts item for the step.\n   */\n  addStart(iterator: Iterator<Traverser<S>>): void {\n    this.start = iterator;\n  }\n\n  /**\n   * Get the name of the step.\n   */\n  abstract getLabel(): string;\n\n  /**\n   * Iterator next\n   */\n  abstract next(): IteratorResult<Traverser<E>>;\n}\n\nexport interface StepConstructor<T> {\n  new (traversal: GraphTraversal<any, any>): T;\n}\n","import { GraphTraversal } from \"../../traversal/graphTraversal\";\nimport { Edge } from \"../../type\";\nimport { MapStep } from \"../map/generic\";\n\nexport class AddEStep extends MapStep<null, Edge> {\n  /**\n   * Default constructor.\n   */\n  constructor(traversal: GraphTraversal<any, any>) {\n    super(\n      \"AddE\",\n      traversal,\n      (): Edge => {\n        return new Edge();\n      },\n    );\n  }\n}\n","import { NodeKey } from \"graphology-types\";\nimport { GraphTraversal } from \"../../traversal/graphTraversal\";\nimport { Path, Traverser, Vertex } from \"../../type\";\nimport { Step } from \"../generic\";\n\n/**\n * Retrieve a list of vertex or all graph vertex.\n * Ex: g.V()\n */\nexport class MapStep<S, T> extends Step<S, T> {\n  label: string;\n  fn: (source: Traverser<S>) => T;\n\n  /**\n   * Default constructor.\n   */\n  constructor(label: string, traversal: GraphTraversal<S, T>, fn: (source: Traverser<S>) => T) {\n    super(traversal);\n    this.label = label;\n    this.fn = fn;\n  }\n\n  getLabel(): string {\n    return this.label;\n  }\n\n  next(): IteratorResult<Traverser<T>> {\n    const ir = this.start.next();\n    if (ir.done) return ir;\n    else {\n      // execute the step with the map function\n      const traverser = ir.value;\n      return {\n        done: ir.done,\n        value: traverser.makeNextTraverser(this.getLabel(), this.fn(traverser)),\n      };\n    }\n  }\n}\n","import { GraphTraversal } from \"../../traversal/graphTraversal\";\nimport { Vertex } from \"../../type\";\nimport { MapStep } from \"../map/generic\";\n\nexport class AddVStep extends MapStep<null, Vertex> {\n  /**\n   * Default constructor.\n   */\n  constructor(traversal: GraphTraversal<any, any>) {\n    super(\n      \"AddV\",\n      traversal,\n      (): Vertex => {\n        const node = traversal.getGraph().addNode(new Date().getTime());\n        return new Vertex(node);\n      },\n    );\n  }\n}\n","import { EdgeKey } from \"graphology-types\";\nimport { Edge, Traverser } from \"../../type\";\nimport { GraphTraversal } from \"../../traversal/graphTraversal\";\nimport { MapStep } from \"../map/generic\";\n\n/**\n * Retrieve a list of edges or all graph edges.\n * Ex: g.E()\n */\nexport class EStep extends MapStep<EdgeKey, Edge> {\n  /**\n   * Default constructor.\n   */\n  constructor(traversal: GraphTraversal<any, any>) {\n    super(\n      \"E\",\n      traversal,\n      (traverser: Traverser<EdgeKey>): Edge => {\n        return new Edge(traverser.value);\n      },\n    );\n  }\n}\n","import { NodeKey } from \"graphology-types\";\nimport { GraphTraversal } from \"../../traversal/graphTraversal\";\nimport { Path, Traverser, Vertex } from \"../../type\";\nimport { MapStep } from \"../map/generic\";\n\n/**\n * Retrieve a list of vertex or all graph vertex.\n * Ex: g.V()\n */\nexport class VStep extends MapStep<NodeKey, Vertex> {\n  /**\n   * Default constructor.\n   */\n  constructor(traversal: GraphTraversal<any, any>) {\n    super(\n      \"V\",\n      traversal,\n      (traverser: Traverser<NodeKey>): Vertex => {\n        const id = traverser.value;\n        const props = traversal.getGraph().getNodeAttributes(id);\n        return new Vertex(id, props[traversal.getConfig().vertex_label_field] || [], props);\n      },\n    );\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { GraphTraversalSource } from \"./traversal/graphTraversalSource\";\n\nexport { GraphTraversalSource };\n"],"sourceRoot":""}